//===========================================================================
// 
// Just another Warcraft III map
// 
//   Warcraft III map script
//   Generated by the Warcraft III World Editor
//   Date: Fri Mar 03 22:30:47 2017
//   Map Author: Unknown
// 
//===========================================================================

//***************************************************************************
//*
//*  Global Variables
//*
//***************************************************************************

globals
    // Generated
    trigger                 gg_trg_SyncInteger         = null
    trigger                 gg_trg_Sync                = null
endglobals

function InitGlobals takes nothing returns nothing
endfunction

//***************************************************************************
//*
//*  Unit Creation
//*
//***************************************************************************

//===========================================================================
function CreateUnitsForPlayer0 takes nothing returns nothing
    local player p = Player(0)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u = CreateUnit( p, 'Hblm', -126.6, 102.2, 228.600 )
    set u = CreateUnit( p, 'hfoo', -81.5, -76.9, 103.033 )
    set u = CreateUnit( p, 'hfoo', 119.6, -117.6, 323.184 )
endfunction

//===========================================================================
function CreatePlayerBuildings takes nothing returns nothing
endfunction

//===========================================================================
function CreatePlayerUnits takes nothing returns nothing
    call CreateUnitsForPlayer0(  )
endfunction

//===========================================================================
function CreateAllUnits takes nothing returns nothing
    call CreatePlayerBuildings(  )
    call CreatePlayerUnits(  )
endfunction

//***************************************************************************
//*
//*  Triggers
//*
//***************************************************************************

//===========================================================================
// Trigger: SyncInteger
//===========================================================================
//TESH.scrollpos=724
//TESH.alwaysfold=0
library Sync requires SyncInteger, optional PlayerUtils
/***************************************************************
*
*   v1.2.1, by TriggerHappy
*   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
*
*   This library allows you to quickly synchronize async data such as,
*   camera position, or a the contents of a local file, to all players
*   in the map by using the game cache.
*
*   Full Documentation: -http://www.hiveworkshop.com/forums/pastebin.php?id=p4f84s
*
*   _________________________________________________________________________
*   1. Installation
*   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
*   Copy the script to your map and save it (requires JassHelper *or* JNGP)
*   _________________________________________________________________________
*   2. API
*   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
*       struct SyncData
*
*           method start takes nothing returns nothing
*           method startChunk takes integer i, integer end returns nothing
*           method refresh takes nothing returns nothing
*           method destroy takes nothing returns nothing
*
*           method addInt takes integer i returns nothing
*           method addReal takes integer i returns nothing
*           method addString takes string s, integer len returns nothing
*           method addBool takes booleanflag returns nothing
*
*           method readInt takes integer index returns integer
*           method readReal takes integer index returns integer
*           method readString takes integer index returns string
*           method readBool takes integer index returns boolean
*
*           method hasInt takes nothing returns boolean
*           method hasReal takes nothing returns boolean
*           method hasString takes nothing returns boolean
*           method hasBool takes nothing returns boolean
*
*           method isPlayerDone takes player p returns boolean
*           method isPlayerIdDone takes integer pid returns boolean
*
*           method addEventListener takes code func returns nothing
*
*           ---------
*
*           filterfunc onComplete
*           filterfunc onError
*           filterfunc onUpdate
*
*           readonly player from
*
*           readonly real timeStarted
*           readonly real timeFinished
*           readonly real timeElapsed
*
*           readonly integer intCount
*           readonly integer boolCount
*           readonly integer strCount
*           readonly integer realCount
*           readonly integer playersDone
*
*           readonly boolean buffering
*
*           readonly static integer last
*           readonly static player LocalPlayer
*           readonly static boolean Initialized
*
*           static method create takes nothing returns SyncData
*           static method destroy takes nothing returns nothing
*           static method gameTime takes nothing returns real
*
*       function GetSyncedData takes nothing returns SyncData
*
***************************************************************/

    globals
        // characters that can be synced (ascii)
        private constant string ALPHABET                    = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~`"

        // safe characters for use in game cache keys
        // (case sensitive)
        private constant string SAFE_KEYS                   = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`{|}~`"

        // how fast the buffer updates
        private constant real UPDATE_PERIOD                 = 0.03125

        // automatically recycle indices when the syncing player leaves
        private constant boolean AUTO_DESTROY_ON_LEAVE      = true

        // automatically stop buffering when an error occurs
        private constant boolean STOP_BUFFERING_ON_ERROR    = true

        // preload game cache key strings on init
        private constant boolean PRELOAD_STR_CACHE          = true
     
        // size of the alphabet
        private constant integer ALPHABET_BASE              = StringLength(ALPHABET)

        // stop reading the string buffer when reaching this char
        private constant string TERM_CHAR                   = "`"

        // maximum number of strings *per instance*
        private constant integer MAX_STRINGS                = 8192

        // filenames for gc
        private constant string CACHE_FILE                  = "i.w3v"
        private constant string CACHE_FILE_STR              = "s.w3v"

        // don't edit below this line
        constant integer EVENT_SYNC_CACHE       = 3
        constant integer SYNC_ERROR_TIMEOUT     = 1
        constant integer SYNC_ERROR_PLAYERLEFT  = 2
    endglobals

    //**************************************************************

    function GetSyncedData takes nothing returns SyncData
        return SyncData(SyncData.Last)
    endfunction

    public function I2Char takes string alphabet, integer i returns string
        return SubString(alphabet, i, i + 1)
    endfunction
 
    public function Char2I takes string alphabet, string c returns integer
        local integer i = 0
        local string s
        local integer l = StringLength(alphabet)
        loop
            set s = I2Char(alphabet, i)
            exitwhen i == l
            if (s == c) then
                return i
            endif
            set i = i + 1
        endloop
        return 0
    endfunction

    public function ConvertBase takes string alphabet, integer i returns string
        local integer b
        local string s = ""
        local integer l = StringLength(alphabet)
        if i < l then
            return I2Char(alphabet, i)
        endif
        loop
            exitwhen i <= 0
            set b = i - ( i / l ) * l
            set s = I2Char(alphabet, b) + s
            set i = i / l
        endloop
        return s
    endfunction

    public function PopulateString takes string s, integer makeLen returns string
        local integer i = 0
        local integer l = StringLength(s)
        if (l == makeLen) then
            return s
        endif
        set l = makeLen-l
        loop
            exitwhen i > l
            set s = s + TERM_CHAR
            set i = i + 1
        endloop
        return s
    endfunction

    //**************************************************************

    globals
        // string table keys
        private constant integer KEY_STR_POS = (0*MAX_STRINGS)
        private constant integer KEY_STR_LEN = (1*MAX_STRINGS)

        // pending data storage space
        private constant integer KEY_STR_CACHE = (2*MAX_STRINGS)
    endglobals
 
    struct SyncData

        real timeout
        filterfunc onComplete
        filterfunc onError
        filterfunc onUpdate

        readonly integer lastError

        readonly player from

        readonly real timeStarted
        readonly real timeFinished
        readonly real timeElapsed

        readonly integer intCount
        readonly integer boolCount
        readonly integer strCount
        readonly integer realCount
        readonly integer playersDone

        readonly boolean buffering
     
        readonly static boolean Initialized = false
        readonly static integer Last        = 0
        readonly static player LocalPlayer
        readonly static integer LocalPlayerID

        private static integer Running   = 0
        private static real timeCounter  = 0.00
        private static trigger EventTrig = CreateTrigger()

        private static hashtable Table
        private static gamecache array Cache
        private static integer array PendingCount
        private static timer Elapsed
        private static timer BufferTimer

        private integer strBufferLen
        private trigger eventTrig
        private string mkey
        private boolean localFinished

        private thistype next
        private thistype prev

        private method resetVars takes nothing returns nothing
            set this.intCount       = 0
            set this.strCount       = 0
            set this.boolCount      = 0
            set this.realCount      = 0
            set this.playersDone    = 0
            set this.strBufferLen   = 0
            set this.timeStarted    = 0
            set this.timeFinished   = 0
            set this.lastError      = 0
            set this.onComplete     = null
            set this.onError        = null
            set this.onUpdate       = null
            set this.timeout        = 0.00
            set this.buffering      = false
            set this.localFinished  = false 
        endmethod

        private static method getKey takes integer pos returns string
            local string position=""
         
            if (HaveSavedString(Table, KEY_STR_CACHE, pos)) then
                return LoadStr(Table, KEY_STR_CACHE, pos)
            endif
         
            set position = ConvertBase(SAFE_KEYS, pos)
            call SaveStr(Table, KEY_STR_CACHE, pos, position)
         
            return position
        endmethod
     
        static method create takes player from returns thistype
            local thistype this

            // Player has to be playing because of GetLocalPlayer use.
            if (GetPlayerController(from) != MAP_CONTROL_USER or GetPlayerSlotState(from) != PLAYER_SLOT_STATE_PLAYING) then
                return 0
            endif

            set this = thistype.allocate()
       
            set this.from   = from
            set this.mkey   = getKey(this-1)

            call this.resetVars()

            set thistype(0).next.prev = this
            set this.next = thistype(0).next
            set thistype(0).next = this

            set this.prev = 0

            return this
        endmethod

        method refresh takes nothing returns nothing
            local integer i = 0
            local integer p = 0
             
            loop
                static if (LIBRARY_PlayerUtils) then
                    exitwhen i == User.AmountPlaying
                    set p = User.fromPlaying(i).id
                else
                    exitwhen i == bj_MAX_PLAYER_SLOTS
                    set p = i
                endif

                call RemoveSavedInteger(Table, this, KEY_STR_POS + p)
                call RemoveSavedInteger(Table, this, KEY_STR_LEN + p)
                call RemoveSavedBoolean(Table, p, this) // playerdone

                set i = i + 1
            endloop

            call FlushStoredMission(Cache[0], this.mkey)
            call FlushStoredMission(Cache[1], this.mkey)

            call this.resetVars()
        endmethod

        method destroy takes nothing returns nothing
            if (this.eventTrig != null) then
                call DestroyTrigger(this.eventTrig)
                set this.eventTrig=null
            endif

            call this.refresh()

            set this.next.prev = this.prev
            set this.prev.next = this.next

            call this.deallocate()
        endmethod
     
        method hasInt takes integer index returns boolean
            return HaveStoredInteger(Cache[0], this.mkey, getKey(index))
        endmethod

        method hasReal takes integer index returns boolean
            return HaveStoredReal(Cache[0], this.mkey, getKey(index))
        endmethod

        method hasBool takes integer index returns boolean
            return HaveStoredBoolean(Cache[0], this.mkey, getKey(index))
        endmethod

        method hasString takes integer index returns boolean
            local integer i = LoadInteger(Table, this, KEY_STR_POS+index)
            if (index > 0 and i == 0) then
                return false
            endif
            return HaveStoredInteger(Cache[1], this.mkey, getKey(i + LoadInteger(Table, this, KEY_STR_LEN+index)))
        endmethod
     
        method addInt takes integer i returns nothing
            local string position=getKey(intCount)
         
            if (LocalPlayer == this.from) then
                call StoreInteger(Cache[0], this.mkey, position, i)
            endif
         
            set intCount=intCount+1
        endmethod

        method addReal takes real i returns nothing
            local string position=getKey(realCount)
         
            if (LocalPlayer == this.from) then
                call StoreReal(Cache[0], this.mkey, position, i)
            endif
         
            set realCount=realCount+1
        endmethod

        method addBool takes boolean flag returns nothing
            local string position=getKey(boolCount)
         
            if (LocalPlayer == this.from) then
                call StoreBoolean(Cache[0], this.mkey, position, flag)
            endif
         
            set boolCount=boolCount+1
        endmethod

        // SyncStoredString doesn't work
        method addString takes string s, integer length returns nothing
            local string position
            local integer i = 0
            local integer strPos = 0
            local integer strLen = 0

            if (StringLength(s) < length) then
                set s = PopulateString(s, length)
            endif
       
            // store the string position in the table
            if (strCount == 0) then
                call SaveInteger(Table, this, KEY_STR_POS, 0)
            else
                set strLen = LoadInteger(Table, this, KEY_STR_LEN + (strCount-1)) + 1
                set strPos = LoadInteger(Table, this, KEY_STR_POS + (strCount-1)) + strLen

                call SaveInteger(Table, this, KEY_STR_POS + strCount, strPos)
            endif

            // convert each character in the string to an integer
            loop
                exitwhen i > length

                set position = getKey(strPos + i)

                if (LocalPlayer == this.from) then
                    call StoreInteger(Cache[1], this.mkey, position, Char2I(ALPHABET, SubString(s, i, i + 1)))
                endif

                set i = i + 1
            endloop

            set strBufferLen = strBufferLen + length
            call SaveInteger(Table, this, KEY_STR_LEN+strCount, length) // store the length as well
            set strCount=strCount+1
        endmethod

        method readInt takes integer index returns integer
            return GetStoredInteger(Cache[0], this.mkey, getKey(index))
        endmethod

        method readReal takes integer index returns real
            return GetStoredReal(Cache[0], this.mkey, getKey(index))
        endmethod

        method readBool takes integer index returns boolean
            return GetStoredBoolean(Cache[0], this.mkey, getKey(index))
        endmethod

        method readString takes integer index returns string
            local string s = ""
            local string c
            local integer i = 0
            local integer strLen = LoadInteger(Table, this, KEY_STR_LEN+index)
            local integer strPos
         
            if (not hasString(index)) then
                return null
            endif

            set strLen = LoadInteger(Table, this, KEY_STR_LEN+index)
            set strPos = LoadInteger(Table, this, KEY_STR_POS+index)
         
            loop
                exitwhen i > strLen
             
                set c = I2Char(ALPHABET, GetStoredInteger(Cache[1], this.mkey, getKey(strPos + i)))

                if (c == TERM_CHAR) then
                    return s
                endif

                set s = s + c
                set i = i + 1
            endloop

            return s
        endmethod

        method addEventListener takes code func returns nothing
            if (this.eventTrig == null) then
                set this.eventTrig = CreateTrigger()
            endif
            call TriggerAddCondition(this.eventTrig, Filter(func))
        endmethod

        public static method gameTime takes nothing returns real
            return timeCounter + TimerGetElapsed(Elapsed)
        endmethod

        private method fireEvent takes filterfunc func returns nothing
            set Last = this

            call TriggerAddCondition(EventTrig, func)
            call TriggerEvaluate(EventTrig)
            call TriggerClearConditions(EventTrig)
        endmethod

        private method error takes integer errorId returns nothing
            set this.lastError = errorId

            if (this.onError != null) then
                call this.fireEvent(this.onError)
            endif

            static if (STOP_BUFFERING_ON_ERROR) then
                set this.buffering = false
            endif
        endmethod
     
        private static method readBuffer takes nothing returns nothing
            local boolean b = true
            local integer i = 0
            local thistype data = thistype(0).next

            loop
                exitwhen data == 0

                // find the nearest instance that is still buffering
                loop
                    exitwhen data.buffering or data == 0
                    set data=data.next
                endloop

                // if none are found, exit
                if (not data.buffering) then
                    return
                endif

                set data.timeElapsed = data.timeElapsed + UPDATE_PERIOD

                if (data.onUpdate != null) then
                    call data.fireEvent(data.onUpdate)
                endif

                if (data.timeout > 0 and data.timeElapsed > data.timeout) then
                    call data.error(SYNC_ERROR_TIMEOUT)
                endif

                // if the player has left, destroy the instance
                if (GetPlayerSlotState(data.from) != PLAYER_SLOT_STATE_PLAYING) then
                    call data.error(SYNC_ERROR_PLAYERLEFT)
                    static if (AUTO_DESTROY_ON_LEAVE) then
                        call data.destroy()
                    endif
                endif

                set b = true

                // make sure all integers have been synced
                if (data.intCount > 0 and  not data.hasInt(data.intCount-1)) then
                    set b = false
                endif

                // make sure all reals have been synced
                if (data.realCount > 0 and not data.hasReal(data.realCount-1)) then
                    set b = false
                endif

                // check strings too
                if (data.strCount > 0 and not data.hasString(data.strCount-1)) then
                    set b = false
                endif

                // and booleans
                if (data.boolCount > 0 and not data.hasBool(data.boolCount-1)) then
                    set b = false
                endif

                // if everything has been synced
                if (b) then

                    if (not data.localFinished) then // async
                        set data.localFinished = true

                        // notify everyone that the local player has recieved all of the data
                        call SyncInteger(LocalPlayerID, data)
                    endif
                     
                endif

                set data = data.next
            endloop
        endmethod
     
        method startChunk takes integer i, integer end returns nothing
            local integer n = 0
            local integer j = 0
            local integer p = 0
            local string position

            // Begin syncing
            loop
                exitwhen i > end

                set position = LoadStr(Table, KEY_STR_CACHE, i)
           
                if (i < intCount and LocalPlayer == this.from) then
                    call SyncStoredInteger(Cache[0], this.mkey, position)
                endif
                if (i < realCount and LocalPlayer == this.from) then
                    call SyncStoredReal(Cache[0], this.mkey, position)
                endif
                if (i < boolCount and LocalPlayer == this.from) then
                    call SyncStoredBoolean(Cache[0], this.mkey, position)
                endif
           
                if (i < strCount and LocalPlayer == this.from) then
                    set n = LoadInteger(Table, this, KEY_STR_LEN + i)
                    set p = LoadInteger(Table, this, KEY_STR_POS + i)
               
                    set j = 0
               
                    loop
                        exitwhen j > n
                   
                        set position = LoadStr(Table, KEY_STR_CACHE, p + j)

                        if (LocalPlayer == this.from) then
                            call SyncStoredInteger(Cache[1], this.mkey, position)
                        endif

                        set j = j + 1
                    endloop
                endif
           
                set i = i + 1
            endloop
         
            if (this.timeStarted != 0.00) then
                return
            endif

            set this.timeStarted = gameTime()
            set this.playersDone = 0
            set this.buffering   = true
            set this.timeElapsed = (UPDATE_PERIOD - TimerGetElapsed(BufferTimer)) * -1
         
            if (Running==0) then
                call TimerStart(BufferTimer, UPDATE_PERIOD, true, function thistype.readBuffer)
            endif

            set Running=Running+1
        endmethod

        method start takes nothing returns nothing
            local integer l = intCount

            // Find the highest count
            if (l < realCount) then
                set l = realCount
            endif
            if (l < strCount) then
                set l = strCount
            endif
            if (l < boolCount) then
                set l = boolCount
            endif

            call startChunk(0, l)
        endmethod

        method isPlayerDone takes player p returns boolean
            return LoadBoolean(Table, GetPlayerId(p), this)
        endmethod

        method isPlayerIdDone takes integer pid returns boolean
            return LoadBoolean(Table, pid, this)
        endmethod

        private static method updateStatus takes nothing returns boolean
            local integer i = 0
            local integer p = GetSyncedPlayerId()
            local boolean b = true
            local boolean c = true
            local thistype data = GetSyncedInteger()
            local triggercondition tc

            if (not data.buffering) then
                return false
            endif
          
            set data.playersDone = data.playersDone + 1
            call SaveBoolean(Table, p, data, true) // set playerdone

            // check if everyone has received the data
            loop
                static if (LIBRARY_PlayerUtils) then
                    exitwhen i == User.AmountPlaying
                    set p = User.fromPlaying(i).id
                    set c = User.fromPlaying(i).isPlaying
                else
                    exitwhen i == bj_MAX_PLAYER_SLOTS
                    set p = i
                    set c = (GetPlayerController(Player(p)) == MAP_CONTROL_USER and GetPlayerSlotState(Player(p)) == PLAYER_SLOT_STATE_PLAYING)
                endif
             
                if (c and not data.isPlayerIdDone(p)) then
                    set b = false // someone hasn't
                endif

                set i = i + 1
            endloop

            // if everyone has recieved the data
            if (b) then
                set Running = Running-1

                if (Running == 0) then
                    call PauseTimer(BufferTimer)
                endif
           
                set data.buffering    = false
                set data.timeFinished = gameTime()
                set data.timeElapsed  = data.timeFinished - data.timeStarted
              
                // fire events
                if (data.onComplete != null) then
                    call data.fireEvent(data.onComplete)
                endif

                if (data.eventTrig != null) then
                    set Last = data
 
                    call TriggerEvaluate(data.eventTrig)
                endif

                call SyncInteger_FireEvents(EVENT_SYNC_CACHE)
            endif

            return false
        endmethod

        private static method trackTime takes nothing returns nothing
            set timeCounter = timeCounter + 10
        endmethod
     
        private static method onInit takes nothing returns nothing
            set Table = InitHashtable()

            set Cache[0] = InitGameCache(CACHE_FILE)
            set Cache[1] = InitGameCache(CACHE_FILE_STR)

            set Elapsed     = CreateTimer()
            set BufferTimer = CreateTimer()

            static if (LIBRARY_PlayerUtils) then
                set LocalPlayer   = User.Local
                set LocalPlayerID = User.fromLocal().id
            else
                set LocalPlayer   = GetLocalPlayer()
                set LocalPlayerID = GetPlayerId(LocalPlayer)
            endif

            call OnSyncInteger(function thistype.updateStatus)
            call TimerStart(Elapsed, 10., true, function thistype.trackTime)
         
            static if (PRELOAD_STR_CACHE) then
                loop
                    exitwhen Last == ALPHABET_BASE
                    call getKey(Last)
                    set Last = Last + 1
                endloop
                set Last = 0
            endif
         
            set Initialized = true
        endmethod

    endstruct

endlibrary
//===========================================================================
// Trigger: Sync
//===========================================================================
//TESH.scrollpos=376
//TESH.alwaysfold=0
library SyncInteger initializer Init uses optional UnitDex, optional GroupUtils, optional xebasic, optional PlayerUtils
/***************************************************************
*
*   v1.0.9, by TriggerHappy
*   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
*
*   This library allows you to send integers to all other players.
*
*   _________________________________________________________________________
*   1. Installation
*   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
*   Copy the script to your map and save it (requires JassHelper *or* JNGP)
*   _________________________________________________________________________
*   2. How it works
*   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
*       1. Creates {DUMMY_COUNT} units and assigns {BASE} of them an integer from 0-{BASE}.
*          The 2nd to last dummy is used to signal when the sequence of numbers is over and
*          the last dummy signifies a negative number.
*
*       2. Breaks down the number you want to sync to one or more {BASE} integers,
*          then selects each dummy unit assoicated with that integer.
*
*       4. The selection event fires for all players when the selection has been sycned
*
*       5. The ID of the selected unit is one of the {BASE} numbers. The current
*          total (starts at 0) is multiplied by {BASE} and the latest synced integer is
*          added to that. The process will repeat until it selects the 2nd to last dummy,
*          and the total is our result.
*   _________________________________________________________________________
*   3. Proper Usage
*   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
*       - Avoid the SyncSelections native. It may cause the thread to hang or
*         make some units un-able to move.
*
*       - Dummies must be select-able (no locust)
*
*       - Run the script in debug mode while testing
*   _________________________________________________________________________
*   4. Function API
*   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
*       function SyncInteger takes integer playerId, integer number returns boolean
*
*       function GetSyncedInteger takes nothing returns integer
*       function GetSyncedPlayer takes nothing returns player
*       function GetSyncedPlayerId takes nothing returns integer
*       function IsPlayerSyncing takes player p returns boolean
*       function IsSyncEnabled takes nothing returns boolean
*       function SyncIntegerToggle takes boolean flag returns nothing
*       function SyncIntegerEnable takes nothing returns nothing
*       function SyncIntegerDisable takes nothing returns nothing
*
*       function OnSyncInteger takes code func returns triggercondition
*       function RemoveSyncEvent takes triggercondition action returns nothing
*       function TriggerRegisterSyncEvent takes trigger t, integer eventtype returns nothing
*
*       function SyncInitialize takes nothing returns nothing
*       function SyncTerminate takes boolean destroyEvent returns nothing
*
*   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
*   -http://www.hiveworkshop.com/threads/syncinteger.278674/
*
*/
        globals
            // calls SyncInitialize automatically
            private constant boolean AUTO_INIT          = true
      
            // owner of the dummy units
            private constant player DUMMY_PLAYER        = Player(PLAYER_NEUTRAL_PASSIVE)
      
            // dummy can *not* have locust (must be selectabe)
            // basically anything should work (like 'hfoo')
            private constant integer DUMMY_ID           = 'hfoo' // XE_DUMMY_UNITID
      
            // dummy ghost ability
            private constant integer DUMMY_ABILITY      = 'Aeth'

            // debug mode
            private constant boolean ALLOW_DEBUGGING    = true
      
            // higher == more dummies but faster
            private constant integer BASE               = 10

            // don't need to change this
            private constant integer DUMMY_COUNT        = BASE+2
      
            // endconfig
            constant integer EVENT_SYNC_INTEGER = 1
      
            private trigger OnSelectTrigger = CreateTrigger()
            private trigger EventTrig       = CreateTrigger()
            private real FireEvent          = 0
      
            private group SelectionGroup

            private integer array SyncData
            private integer LastPlayer
            private integer LastSync
            private unit array SyncIntegerDummy
            private integer array AttachedInteger
            private player LocalPlayer
        endglobals
  
        function GetSyncedInteger takes nothing returns integer
            return LastSync
        endfunction
  
        function GetSyncedPlayer takes nothing returns player
            return Player(LastPlayer)
        endfunction
  
        function GetSyncedPlayerId takes nothing returns integer
            return LastPlayer
        endfunction
  
        function IsPlayerSyncing takes player p returns boolean
            return (SyncData[GetPlayerId(p)] != -1)
        endfunction
  
        function IsPlayerIdSyncing takes integer pid returns boolean
            return (SyncData[pid] != -1)
        endfunction

        function IsSyncEnabled takes nothing returns boolean
            return IsTriggerEnabled(OnSelectTrigger)
        endfunction
  
        function SyncIntegerEnable takes nothing returns nothing
            call EnableTrigger(OnSelectTrigger)
        endfunction
  
        function SyncIntegerDisable takes nothing returns nothing
            call DisableTrigger(OnSelectTrigger)
        endfunction
  
        function SyncIntegerToggle takes boolean flag returns nothing
            if (flag) then
                call EnableTrigger(OnSelectTrigger)
            else
                call DisableTrigger(OnSelectTrigger)
            endif
        endfunction
  
        function OnSyncInteger takes code func returns triggercondition
            return TriggerAddCondition(EventTrig, Filter(func))
        endfunction

        function RemoveSyncEvent takes triggercondition action returns nothing
           call TriggerRemoveCondition(EventTrig, action)
        endfunction
  
  
        function SyncInteger takes integer playerId, integer number returns boolean
            local integer x = number
            local integer i = 0
            local integer d = BASE
            local integer j = 0
            local integer n = 0
            local integer l = 0
            local unit u
            local unit last
            local player p

            static if (ALLOW_DEBUGGING and DEBUG_MODE) then
                if (OnSelectTrigger == null) then
                    call BJDebugMsg(SCOPE_PREFIX + "SyncInteger: OnSelectTrigger is destroyed")
                endif
          
                if (not IsSyncEnabled()) then
                    call BJDebugMsg(SCOPE_PREFIX + "SyncInteger: OnSelectTrigger is disabled")
                endif
            endif
      
            if (not IsSyncEnabled()) then
                return false
            endif
      
            if (number < 0) then
                set d = DUMMY_COUNT-1
                set number = number * -1
            endif
  
            set p = Player(playerId)
      
            loop
                set x = x/(BASE)
                exitwhen x==0
                set i=i+1
            endloop
      
            // Count how many units are selected
            call GroupEnumUnitsSelected(SelectionGroup, p, null)
            set bj_groupCountUnits = 0

            set u = FirstOfGroup(SelectionGroup)
            loop
                exitwhen u == null
                set last = u
                call GroupRemoveUnit(SelectionGroup, u)
                set bj_groupCountUnits = bj_groupCountUnits + 1
                set u = FirstOfGroup(SelectionGroup)
            endloop
          
            // If the queue is full, de-select the last unit which
            // will allow us to select a dummy, and hopefully
            // avoid a flickering effect.
            if (bj_groupCountUnits >= 12 and LocalPlayer == p) then
                call SelectUnit(last, false)
            endif

            set j=R2I(Pow(BASE, i))

            loop
                set n = j
                set x = number/n
                set j = j / BASE
              
                if (LocalPlayer == p) then
                    call SelectUnit(SyncIntegerDummy[x], true)
                    call SelectUnit(SyncIntegerDummy[x], false)
                endif
          
                set number = number-x*n

                exitwhen i == 0
          
                set i = i - 1
            endloop
  
            if (LocalPlayer == p) then
                call SelectUnit(SyncIntegerDummy[d], true)
                call SelectUnit(SyncIntegerDummy[d], false)

                if (bj_groupCountUnits >= 12) then
                    call SelectUnit(last, true)
                endif
            endif

            set u = null
            set last = null

            return true
        endfunction
  
        //this cleans up all dummies and triggers created by the system
        function SyncTerminate takes boolean destroyEvents returns nothing
            local integer i = 0
      
            if (destroyEvents) then
                call DestroyTrigger(OnSelectTrigger)
                call DestroyTrigger(EventTrig)
                set OnSelectTrigger = null
                set EventTrig = null

                static if not LIBRARY_GroupUtils then
                    call DestroyGroup(SelectionGroup)
                    set SelectionGroup = null
                endif
            else
                call SyncIntegerDisable()
            endif
      
            loop
                exitwhen i >= DUMMY_COUNT
                call RemoveUnit(SyncIntegerDummy[i])
                set SyncIntegerDummy[i] = null
                set i = i + 1
            endloop
        endfunction
  
        function SyncInitialize takes nothing returns nothing
            local integer i = 0
      
            static if (ALLOW_DEBUGGING and DEBUG_MODE) then
                if (OnSelectTrigger == null) then
                    call BJDebugMsg(SCOPE_PREFIX + "SyncInitialize: OnSelectTrigger is null and has no events attached to it")
                endif
            endif
      
            loop
                exitwhen i >= DUMMY_COUNT
                set SyncIntegerDummy[i]=CreateUnit(DUMMY_PLAYER, DUMMY_ID, 1000000, 1000000, i)
          
                static if (ALLOW_DEBUGGING and DEBUG_MODE) then
                    if (i == 0) then // display once
                        if (SyncIntegerDummy[i] == null) then
                            call BJDebugMsg(SCOPE_PREFIX + "SyncInitialize: Dummy unit is null (check DUMMY_ID)")
                        endif
              
                        if (GetUnitAbilityLevel(SyncIntegerDummy[i], 'Aloc') > 0) then
                            call BJDebugMsg(SCOPE_PREFIX + "SyncInitialize: Dummy units must be selectable (detected locust)")
                            call UnitRemoveAbility(SyncIntegerDummy[i], 'Aloc')
                        endif
                    endif
                endif
            
                static if (LIBRARY_UnitDex) then
                    set AttachedInteger[GetUnitId(SyncIntegerDummy[i])] = i + 1
                else
                    call SetUnitUserData(SyncIntegerDummy[i], i + 1)
                endif

                call UnitAddAbility(SyncIntegerDummy[i], DUMMY_ABILITY)
                call PauseUnit(SyncIntegerDummy[i], true)
                set i = i + 1
            endloop
      
            if (GetExpiredTimer() != null) then
                call DestroyTimer(GetExpiredTimer())
            endif
        endfunction
  
        private function OnSelect takes nothing returns boolean
            local unit u        = GetTriggerUnit()
            local player p      = GetTriggerPlayer()
            local integer id    = GetPlayerId(p)
            local boolean isNeg = (SyncIntegerDummy[DUMMY_COUNT-1] == u)
            local integer index

            static if (LIBRARY_UnitDex) then
                set index = AttachedInteger[GetUnitId(u)] - 1
            else
                set index = GetUnitUserData(u) - 1
            endif

            if (index == -1 or SyncIntegerDummy[index] != u) then
                set u = null
                return false
            endif

            static if (ALLOW_DEBUGGING and DEBUG_MODE) then
                if (OnSelectTrigger == null) then
                    call BJDebugMsg(SCOPE_PREFIX + "SyncInteger: OnSelectTrigger is null")
                endif
            endif
      
            if (isNeg) then
                set SyncData[id] = SyncData[id]*-1
            endif

            if (isNeg or SyncIntegerDummy[DUMMY_COUNT-2] == u) then
                set LastPlayer   = id
                set LastSync     = SyncData[id]
                set SyncData[id] = -1

                // run "events"
                set FireEvent = EVENT_SYNC_INTEGER
                call TriggerEvaluate(EventTrig)
                set FireEvent = 0
            else
                if (SyncData[id]==-1)then
                    set SyncData[id]=0
                endif
                set SyncData[id] = SyncData[id] * BASE + index
            endif
      
            set u = null
      
            return false
        endfunction
  
        public function FireEvents takes real eventtype returns nothing
            set FireEvent = eventtype
            set FireEvent = 0
        endfunction

        //===========================================================================
        private function Init takes nothing returns nothing
            local integer i = 0
            local integer j
      
            loop
                call TriggerRegisterPlayerUnitEvent(OnSelectTrigger, Player(i), EVENT_PLAYER_UNIT_SELECTED, null)
          
                set SyncData[i] = -1
          
                set i = i + 1
                exitwhen i==bj_MAX_PLAYER_SLOTS
            endloop

            call TriggerAddCondition(OnSelectTrigger, Filter(function OnSelect))
      
            static if (AUTO_INIT) then
                call TimerStart(CreateTimer(), 0, false, function SyncInitialize)
            endif
      
            static if (LIBRARY_GroupUtils) then
                set SelectionGroup=ENUM_GROUP
            else
                set SelectionGroup=CreateGroup()
            endif

            static if (LIBRARY_PlayerUtils) then
                set LocalPlayer=User.Local
            else
                set LocalPlayer=GetLocalPlayer()
            endif
        endfunction

endlibrary//===========================================================================
function InitCustomTriggers takes nothing returns nothing
    call InitTrig_SyncInteger(  )
    call InitTrig_Sync(  )
endfunction

//***************************************************************************
//*
//*  Players
//*
//***************************************************************************

function InitCustomPlayerSlots takes nothing returns nothing

    // Player 0
    call SetPlayerStartLocation( Player(0), 0 )
    call SetPlayerColor( Player(0), ConvertPlayerColor(0) )
    call SetPlayerRacePreference( Player(0), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(0), true )
    call SetPlayerController( Player(0), MAP_CONTROL_USER )

endfunction

function InitCustomTeams takes nothing returns nothing
    // Force: TRIGSTR_002
    call SetPlayerTeam( Player(0), 0 )

endfunction

//***************************************************************************
//*
//*  Main Initialization
//*
//***************************************************************************

//===========================================================================
function main takes nothing returns nothing
    call SetCameraBounds( -3328.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), -3584.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 3328.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 3072.0 - GetCameraMargin(CAMERA_MARGIN_TOP), -3328.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), 3072.0 - GetCameraMargin(CAMERA_MARGIN_TOP), 3328.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), -3584.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM) )
    call SetDayNightModels( "Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl", "Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl" )
    call NewSoundEnvironment( "Default" )
    call SetAmbientDaySound( "LordaeronSummerDay" )
    call SetAmbientNightSound( "LordaeronSummerNight" )
    call SetMapMusic( "Music", true, 0 )
    call CreateAllUnits(  )
    call InitBlizzard(  )
    call InitGlobals(  )
    call InitCustomTriggers(  )

endfunction

//***************************************************************************
//*
//*  Map Configuration
//*
//***************************************************************************

function config takes nothing returns nothing
    call SetMapName( "Just another Warcraft III map" )
    call SetMapDescription( "Nondescript" )
    call SetPlayers( 1 )
    call SetTeams( 1 )
    call SetGamePlacement( MAP_PLACEMENT_USE_MAP_SETTINGS )

    call DefineStartLocation( 0, 2240.0, -2496.0 )

    // Player setup
    call InitCustomPlayerSlots(  )
    call SetPlayerSlotAvailable( Player(0), MAP_CONTROL_USER )
    call InitGenericPlayerSlots(  )
endfunction

